# Модуль операций с матрицами на языке Nim
# Реализация основных матричных операций


# Импорт необходимых модулей из стандартной библиотеки Nim
import std/[strutils, math]  # strutils для работы со строками, math для математических операций


# Определяем тип Matrix как последовательность последовательностей float
# Звездочка (*) означает, что тип экспортируется (публичный) из модуля
type Matrix* = seq[seq[float]]  # Двумерный массив чисел с плавающей точкой


proc createMatrix*(rows, cols: int): Matrix =
  ## Создает новую матрицу заданного размера, заполненную нулями
  ## rows: количество строк (целое число, больше 0)
  ## cols: количество столбцов (целое число, больше 0)
  ## Возвращает: матрицу размера rows x cols, заполненную нулями
  
  # Создаем внешнюю последовательность (строки) длиной rows
  result = newSeq[seq[float]](rows)  # result - специальная переменная в Nim для возвращаемого значения
  
  # Для каждой строки создаем внутреннюю последовательность (столбцы) длиной cols
  for i in 0..<rows:  # Диапазон 0..<rows означает от 0 до rows-1 включительно
    result[i] = newSeq[float](cols)  # Инициализируем каждую строку последовательностью нулей

proc createMatrixFromArray*(data: seq[seq[float]]): Matrix =
  ## Создает матрицу из двумерной последовательности чисел
  ## data: двумерная последовательность чисел
  ## Возвращает: матрицу с данными из последовательности
  
  # Получаем количество строк
  let rows = data.len
  
  # Если данных нет, возвращаем пустую матрицу
  if rows == 0:
    return createMatrix(0, 0)
  
  # Получаем количество столбцов из первой строки
  let cols = data[0].len
  
  # Создаем матрицу нужного размера
  result = createMatrix(rows, cols)
  
  # Копируем данные из последовательности в матрицу
  for i in 0..<rows:
    # Проверяем, что все строки имеют одинаковую длину
    if data[i].len != cols:
      raise newException(ValueError, "Все строки должны иметь одинаковую длину")
    
    # Копируем элементы
    for j in 0..<cols:
      result[i][j] = data[i][j]


proc inputMatrix*(): Matrix =
  ## Запрашивает у пользователя ввод матрицы через консоль
  ## Возвращает: введенную пользователем матрицу
  
  # Шаг 1: Ввод количества строк
  echo "Введите количество строк:"
  var rowsStr = readLine(stdin).strip()  # Читаем строку, удаляем пробелы по краям
  
  # Проверяем, что строка не пустая
  while rowsStr == "":
    echo "Пожалуйста, введите количество строк:"
    rowsStr = readLine(stdin).strip()
  
  # Преобразуем строку в целое число с обработкой ошибок
  let rows = try:
    rowsStr.parseInt()  # Пытаемся преобразовать строку в целое число
  except ValueError:  # Если не удалось (пользователь ввел не число)
    echo "Ошибка: введите целое число"
    return inputMatrix()  # Рекурсивно вызываем функцию снова
  
  # Проверяем, что количество строк положительное
  if rows <= 0:
    echo "Ошибка: количество строк должно быть положительным"
    return inputMatrix()
  
  # Шаг 2: Ввод количества столбцов (аналогично строкам)
  echo "Введите количество столбцов:"
  var colsStr = readLine(stdin).strip()
  
  while colsStr == "":
    echo "Пожалуйста, введите количество столбцов:"
    colsStr = readLine(stdin).strip()
  
  let cols = try:
    colsStr.parseInt()
  except ValueError:
    echo "Ошибка: введите целое число"
    return inputMatrix()
  
  if cols <= 0:
    echo "Ошибка: количество столбцов должно быть положительным"
    return inputMatrix()
  
  # Создаем матрицу нужного размера
  var matrix = createMatrix(rows, cols)
  
  # Инструкции для пользователя
  echo "Введите матрицу " & $rows & "x" & $cols & " построчно (в каждой строке " & $cols & " чисел, разделенных пробелами):"
  echo "Пример строки: 1 2.5 3.14"
  
  # Шаг 3: Ввод элементов построчно
  for i in 0..<rows:
    while true:  # Цикл продолжается до тех пор, пока пользователь не введет корректную строку
      echo "Строка " & $(i+1) & ":"  # Нумерация строк для пользователя начинается с 1
      let line = readLine(stdin).strip()
      
      # Проверка на пустую строку
      if line == "":
        echo "Строка не может быть пустой. Попробуйте снова."
        continue  # Переходим к следующей итерации цикла
      
      # Разбиваем строку на элементы по пробелам
      let elements = line.splitWhitespace()
      
      # Проверяем количество элементов
      if elements.len != cols:
        echo "Ошибка: ожидается " & $cols & " элементов, получено " & $elements.len & ". Попробуйте снова."
        
        # Создаем пример правильного ввода для пользователя
        var example = ""
        for k in 0..<cols:
          example.add("1.0")
          if k < cols - 1:
            example.add(" ")
        echo "Пример правильного ввода: " & example
        
        continue
      
      # Проверяем, что все элементы - корректные числа
      var allValid = true  # Флаг корректности всех элементов
      for j in 0..<cols:
        try:
          # Пытаемся преобразовать строку в число с плавающей точкой
          matrix[i][j] = elements[j].parseFloat()
        except ValueError:  # Если не удалось
          echo "Ошибка: '" & elements[j] & "' не является числом. Попробуйте снова."
          allValid = false  # Устанавливаем флаг в false
          break  # Прерываем внутренний цикл
      
      # Если все элементы корректны, выходим из цикла while
      if allValid:
        break
  
  # Возвращаем введенную матрицу
  return matrix

proc printMatrix*(m: Matrix) =
  ## Выводит матрицу в консоль в красивом формате
  ## m: матрица для вывода
  
  # Проверка на пустую матрицу
  if m.len == 0:
    echo "[Пустая матрица]"
    return  # Завершаем выполнение функции
  
  # Получаем размеры матрицы
  let rows = m.len        # Количество строк
  let cols = m[0].len     # Количество столбцов (берем длину первой строки)
  
  # Шаг 1: Находим максимальную длину строкового представления числа
  # Это нужно для красивого выравнивания при выводе
  var maxLen = 0  # Начальное значение максимальной длины
  
  for i in 0..<rows:
    for j in 0..<cols:
      # Форматируем число с 2 знаками после запятой и получаем длину строки
      let strLen = formatFloat(m[i][j], ffDecimal, precision = 2).len
      
      # Обновляем максимальную длину если текущая больше
      if strLen > maxLen:
        maxLen = strLen
  
  # Шаг 2: Выводим матрицу с выравниванием
  echo "Матрица " & $rows & "x" & $cols & ":"  # Заголовок с размерами
  
  for i in 0..<rows:
    stdout.write "[ "  # Начало строки матрицы
    
    for j in 0..<cols:
      # Форматируем число
      let numStr = formatFloat(m[i][j], ffDecimal, precision = 2)
      
      # Выводим число с выравниванием по правому краю
      stdout.write align(numStr, maxLen)
      
      # Добавляем пробелы между элементами (кроме последнего)
      if j < cols - 1:
        stdout.write "  "
    
    echo " ]"  # Конец строки матрицы и переход на новую строку


proc addMatrices*(a, b: Matrix): Matrix =
  ## Сложение двух матриц
  ## a, b: матрицы для сложения
  ## Возвращает: сумму матриц a + b
  
  # Проверка на пустые матрицы
  if a.len == 0 or b.len == 0:
    raise newException(ValueError, "Матрицы не могут быть пустыми")
  
  # Проверка совпадения размеров (необходимое условие для сложения)
  if a.len != b.len or a[0].len != b[0].len:
    # Создаем информативное сообщение об ошибке
    let errorMsg = "Матрицы должны быть одного размера для сложения. " &
                   "Первая: " & $a.len & "x" & $a[0].len & ", вторая: " & $b.len & "x" & $b[0].len
    raise newException(ValueError, errorMsg)
  
  # Создаем матрицу для результата того же размера, что и входные матрицы
  result = createMatrix(a.len, a[0].len)
  
  # Поэлементное сложение
  for i in 0..<a.len:
    for j in 0..<a[0].len:
      result[i][j] = a[i][j] + b[i][j]

proc multiplyMatrices*(a, b: Matrix): Matrix =
  ## Умножение двух матриц
  ## a, b: матрицы для умножения (a * b)
  ## Возвращает: произведение матриц a * b
  
  # Проверка на пустые матрицы
  if a.len == 0 or b.len == 0:
    raise newException(ValueError, "Матрицы не могут быть пустыми")
  
  # Проверка условия умножения матриц:
  # Количество столбцов первой матрицы должно равняться количеству строк второй
  if a[0].len != b.len:
    # Создаем информативное сообщение об ошибке
    let errorMsg = "Невозможно умножить матрицы: количество столбцов первой (" & $a[0].len & ") " &
                   "должно равняться количеству строк второй (" & $b.len & ")"
    raise newException(ValueError, errorMsg)
  
  # Создаем матрицу для результата:
  # Количество строк как у первой матрицы, столбцов как у второй
  result = createMatrix(a.len, b[0].len)
  
  # Алгоритм умножения матриц (строка на столбец)
  for i in 0..<a.len:              # Для каждой строки первой матрицы
    for j in 0..<b[0].len:         # Для каждого столбца второй матрицы
      var sum = 0.0                # Накопитель для суммы
      
      for k in 0..<a[0].len:       # Для каждого элемента строки/столбца
        # Умножаем элемент строки i первой матрицы на элемент столбца j второй матрицы
        sum += a[i][k] * b[k][j]
      
      # Сохраняем результат в результирующую матрицу
      result[i][j] = sum

proc transposeMatrix*(m: Matrix): Matrix =
  ## Транспонирование матрицы (строки становятся столбцами и наоборот)
  ## m: исходная матрица
  ## Возвращает: транспонированную матрицу
  
  # Проверка на пустую матрицу
  if m.len == 0:
    return createMatrix(0, 0)  # Транспонирование пустой матрицы - пустая матрица
  
  # Получаем размеры исходной матрицы
  let rows = m.len      # Количество строк исходной матрицы
  let cols = m[0].len   # Количество столбцов исходной матрицы
  
  # Создаем матрицу с обратными размерами (столбцы становятся строками и наоборот)
  result = createMatrix(cols, rows)
  
  # Заполняем транспонированную матрицу
  for i in 0..<rows:
    for j in 0..<cols:
      result[j][i] = m[i][j]  # Элемент [i,j] исходной становится [j,i] в транспонированной

proc determinant*(m: Matrix): float =
  ## Вычисление определителя квадратной матрицы (рекурсивный алгоритм)
  ## m: квадратная матрица
  ## Возвращает: определитель матрицы
  
  # Проверка на пустую матрицу
  if m.len == 0:
    raise newException(ValueError, "Матрица не может быть пустой")
  
  # Проверка, что матрица квадратная (необходимое условие для определителя)
  if m.len != m[0].len:
    let errorMsg = "Матрица должна быть квадратной для вычисления определителя. " &
                   "Получена матрица " & $m.len & "x" & $m[0].len
    raise newException(ValueError, errorMsg)
  
  let n = m.len  # Размер квадратной матрицы (n x n)
  
  # Базовые случаи рекурсии:
  
  # Матрица 1x1: определитель равен единственному элементу
  if n == 1:
    return m[0][0]
  
  # Матрица 2x2: вычисляем по формуле ad - bc
  if n == 2:
    return m[0][0] * m[1][1] - m[0][1] * m[1][0]
  
  # Матрица 3x3: вычисляем по правилу Саррюса (треугольников)
  if n == 3:
    # Правило Саррюса:
    # Сумма произведений элементов главных диагоналей минус
    # сумма произведений элементов побочных диагоналей
    return m[0][0]*m[1][1]*m[2][2] + 
           m[0][1]*m[1][2]*m[2][0] + 
           m[0][2]*m[1][0]*m[2][1] -
           m[0][2]*m[1][1]*m[2][0] - 
           m[0][0]*m[1][2]*m[2][1] - 
           m[0][1]*m[1][0]*m[2][2]
  
  # Рекурсивный случай для матриц большего размера (n > 3):
  # Разложение определителя по первой строке (метод Лапласа)
  
  var det = 0.0  # Накопитель для определителя
  
  # Проходим по всем элементам первой строки
  for j in 0..<n:
    # Создаем минор (n-1)x(n-1) - матрица без первой строки и j-го столбца
    var minor = createMatrix(n-1, n-1)
    
    # Заполняем минор
    for i in 1..<n:              # Начинаем со второй строки (индекс 1)
      var colIndex = 0           # Индекс столбца в миноре
      
      for k in 0..<n:            # Проходим по всем столбцам исходной матрицы
        if k != j:               # Пропускаем j-й столбец
          minor[i-1][colIndex] = m[i][k]  # Копируем элемент в минор
          colIndex += 1          # Увеличиваем индекс столбца в миноре
    
    # Определяем знак для текущего элемента: (-1)^(1+j)
    let sign = if j mod 2 == 0: 1.0 else: -1.0  # Четные столбцы: +, нечетные: -
    
    # Рекурсивно вычисляем определитель минора и добавляем к общей сумме
    det += sign * m[0][j] * determinant(minor)
  
  # Возвращаем вычисленный определитель
  return det



proc isSquare*(m: Matrix): bool =
  ## Проверяет, является ли матрица квадратной
  ## m: матрица для проверки
  ## Возвращает: true если матрица квадратная, false в противном случае
  
  # Матрица квадратная если:
  # 1. Она не пустая (m.len > 0)
  # 2. Количество строк равно количеству столбцов
  m.len > 0 and m.len == m[0].len

proc getIdentityMatrix*(n: int): Matrix =
  ## Создает единичную матрицу размера n x n
  ## n: размер матрицы (целое число > 0)
  ## Возвращает: единичную матрицу размера n x n
  
  # Проверка корректности размера
  if n <= 0:
    raise newException(ValueError, "Размер должен быть положительным")
  
  # Создаем матрицу размера n x n, заполненную нулями
  result = createMatrix(n, n)
  
  # Заполняем главную диагональ единицами
  for i in 0..<n:
    result[i][i] = 1.0  # Элементы с одинаковыми индексами (i,i) = 1

proc scalarMultiply*(m: Matrix, scalar: float): Matrix =
  ## Умножает матрицу на скаляр (каждый элемент умножается на число)
  ## m: исходная матрица
  ## scalar: число-множитель
  ## Возвращает: матрицу, умноженную на скаляр
  
  # Проверка на пустую матрицу
  if m.len == 0:
    return createMatrix(0, 0)
  
  # Создаем матрицу того же размера
  result = createMatrix(m.len, m[0].len)
  
  # Умножаем каждый элемент на скаляр
  for i in 0..<m.len:
    for j in 0..<m[0].len:
      result[i][j] = m[i][j] * scalar
